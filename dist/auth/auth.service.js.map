{"version":3,"sources":["../../src/auth/auth.service.ts"],"sourcesContent":["import { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { UsersService } from '../users/users.service';\nimport { JwtService } from '@nestjs/jwt';\nimport { PrismaService } from '../prisma/prisma.service';\nimport * as bcrypt from 'bcrypt';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private usersService: UsersService,\n    private jwtService: JwtService,\n    private prisma: PrismaService,\n  ) {}\n\n  async validateUser(email: string, pass: string): Promise<any> {\n    const user = await this.usersService.findOne(email);\n    if (user && (await bcrypt.compare(pass, user.password))) {\n      const { password, ...result } = user;\n      return result;\n    }\n    return null;\n  }\n\n  async login(user: any) {\n    const payload = { email: user.email, sub: user.id, role: user.role };\n\n    // Create login history\n    await this.prisma.loginHistory.create({\n      data: {\n        userId: user.id,\n        // IP and device could be extracted from request context if passed\n      },\n    });\n\n    return {\n      access_token: this.jwtService.sign(payload),\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name,\n        role: user.role,\n      },\n    };\n  }\n\n  async logout(userId: string) {\n    const lastLogin = await this.prisma.loginHistory.findFirst({\n      where: { userId, logoutTime: null },\n      orderBy: { loginTime: 'desc' },\n    });\n\n    if (lastLogin) {\n      await this.prisma.loginHistory.update({\n        where: { id: lastLogin.id },\n        data: { logoutTime: new Date() },\n      });\n    }\n    return { message: 'Logged out successfully' };\n  }\n\n  async register(registerDto: any) {\n    const hashedPassword = await bcrypt.hash(registerDto.password, 10);\n    const user = await this.usersService.create({\n      ...registerDto,\n      password: hashedPassword,\n    });\n    return this.login(user);\n  }\n}\n"],"names":["AuthService","validateUser","email","pass","user","usersService","findOne","bcrypt","compare","password","result","login","payload","sub","id","role","prisma","loginHistory","create","data","userId","access_token","jwtService","sign","name","logout","lastLogin","findFirst","where","logoutTime","orderBy","loginTime","update","Date","message","register","registerDto","hashedPassword","hash"],"mappings":";;;;+BAOaA;;;eAAAA;;;wBAPqC;8BACrB;qBACF;+BACG;gEACN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGjB,IAAA,AAAMA,cAAN,MAAMA;IAOX,MAAMC,aAAaC,KAAa,EAAEC,IAAY,EAAgB;QAC5D,MAAMC,OAAO,MAAM,IAAI,CAACC,YAAY,CAACC,OAAO,CAACJ;QAC7C,IAAIE,QAAS,MAAMG,QAAOC,OAAO,CAACL,MAAMC,KAAKK,QAAQ,GAAI;YACvD,MAAM,EAAEA,QAAQ,EAAE,GAAGC,QAAQ,GAAGN;YAChC,OAAOM;QACT;QACA,OAAO;IACT;IAEA,MAAMC,MAAMP,IAAS,EAAE;QACrB,MAAMQ,UAAU;YAAEV,OAAOE,KAAKF,KAAK;YAAEW,KAAKT,KAAKU,EAAE;YAAEC,MAAMX,KAAKW,IAAI;QAAC;QAEnE,uBAAuB;QACvB,MAAM,IAAI,CAACC,MAAM,CAACC,YAAY,CAACC,MAAM,CAAC;YACpCC,MAAM;gBACJC,QAAQhB,KAAKU,EAAE;YAEjB;QACF;QAEA,OAAO;YACLO,cAAc,IAAI,CAACC,UAAU,CAACC,IAAI,CAACX;YACnCR,MAAM;gBACJU,IAAIV,KAAKU,EAAE;gBACXZ,OAAOE,KAAKF,KAAK;gBACjBsB,MAAMpB,KAAKoB,IAAI;gBACfT,MAAMX,KAAKW,IAAI;YACjB;QACF;IACF;IAEA,MAAMU,OAAOL,MAAc,EAAE;QAC3B,MAAMM,YAAY,MAAM,IAAI,CAACV,MAAM,CAACC,YAAY,CAACU,SAAS,CAAC;YACzDC,OAAO;gBAAER;gBAAQS,YAAY;YAAK;YAClCC,SAAS;gBAAEC,WAAW;YAAO;QAC/B;QAEA,IAAIL,WAAW;YACb,MAAM,IAAI,CAACV,MAAM,CAACC,YAAY,CAACe,MAAM,CAAC;gBACpCJ,OAAO;oBAAEd,IAAIY,UAAUZ,EAAE;gBAAC;gBAC1BK,MAAM;oBAAEU,YAAY,IAAII;gBAAO;YACjC;QACF;QACA,OAAO;YAAEC,SAAS;QAA0B;IAC9C;IAEA,MAAMC,SAASC,WAAgB,EAAE;QAC/B,MAAMC,iBAAiB,MAAM9B,QAAO+B,IAAI,CAACF,YAAY3B,QAAQ,EAAE;QAC/D,MAAML,OAAO,MAAM,IAAI,CAACC,YAAY,CAACa,MAAM,CAAC;YAC1C,GAAGkB,WAAW;YACd3B,UAAU4B;QACZ;QACA,OAAO,IAAI,CAAC1B,KAAK,CAACP;IACpB;IA3DA,YACE,AAAQC,YAA0B,EAClC,AAAQiB,UAAsB,EAC9B,AAAQN,MAAqB,CAC7B;aAHQX,eAAAA;aACAiB,aAAAA;aACAN,SAAAA;IACP;AAwDL"}